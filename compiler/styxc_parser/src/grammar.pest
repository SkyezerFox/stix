// whitespace
BLANK = _{ " " | "\t" }
WHITESPACE = _{ BLANK | NEWLINE }
// comments
line_comment = { "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
block_comment = { "/*" ~ ANY* ~ "*/" }
COMMENT = _{ block_comment | line_comment }

ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

int_hex = @{ "0x" ~ (ASCII_HEX_DIGIT | "_")+ }
int_oct = @{ "0o" ~ ('0'..'7' | "_")+ }
int_bin = @{ "0b" ~ ("0" | "1" | "_")+ }
int = @{ int_hex | int_oct | int_bin | (ASCII_DIGIT | "_")+ }

float_hex = @{ "0x" ~ ((ASCII_HEX_DIGIT | "_")* ~ "." ~ (ASCII_HEX_DIGIT | "_")+) | ((ASCII_HEX_DIGIT | "_")+ ~ "." ~ (ASCII_HEX_DIGIT | "_")*) }
float_oct = @{ "0o" ~ (('0'..'7' | "_")* ~ "." ~ ('0'..'7' | "_")+) | (('0'..'7' | "_")+ ~ "." ~ ('0'..'7' | "_")*) }
float_bin = @{ "0b" ~ (("0" | "1" | "_")* ~ "." ~ ("0" | "1" | "_")+) | (("0" | "1" | "_")+ ~ "." ~ ("0" | "1" | "_")*) }
float = @{ float_hex | float_oct | float_bin }

raw_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
char_inner = @{ raw_char }
char = ${ "'" ~ char_inner ~ "'" }

string_inner = @{ raw_char* }
string = ${ "\"" ~ string_inner ~ "\"" }

bool = { "true" | "false" }

tuple = { "(" ~ (expr ~ "," )+ ~ expr ~ ")" }
array = { "[" ~ (expr ~ ",")+ ~ expr ~ "]" }

array_type_op = { "[]" }
tuple_type = !{ "(" ~ (type_ident ~ "," )+ ~ type_ident ~ ")" }
type_ident = !{ tuple_type | type_ident ~ array_type_op | ident }

type_binary_op_union = { "|" }
type_binary_op_intersect = { "&" }
type_binary_op = { type_binary_op_union | type_binary_op_intersect }
type_binary_expr = {}

literal = { tuple | string | char | bool | array | float | int }

expr = ${ conditional_stmt | func_call binary_expr | unary_expr | literal | ident }

mut_token = { "mut" }
let_declaration = !{ "let" ~ (mut_token? ~ ident ~ ",")* ~ mut_token? ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
mut_declaration = !{ mut_token ~ (ident? ~ ",")* ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
declaration = _{ let_declaration | mut_declaration }

block = !{ "{" ~ statement* ~ "}" }

if_stmt = !{ "if" ~ expr ~ block }
else_stmt = !{ "else" ~ block }
else_if_stmt = !{ "else" ~ "if" ~ expr ~ block }
conditional_stmt = !{ if_stmt ~ else_if_stmt* ~ else_stmt? }

loop_stmt = !{ "loop" ~ ident? ~ block }
while_stmt = !{ "while" ~ expr ~ block }
break_stmt = !{ "break" ~ ident? }

unary_op_bitwise_not = { "~" }
unary_op_logical_not = { "!" }
unary_op_reference = { "&" }
unary_op_dereference = { "*" }

unary_op_prefix = {
	unary_op_bitwise_not
	| unary_op_logical_not
	| unary_op_reference
	| unary_op_dereference
}

unary_op_increment = { "++" }
unary_op_decrement = { "--" }

unary_op_suffix = {
	unary_op_increment
	| unary_op_decrement
}

unary_expr = !{ (unary_op_prefix? ~ expr ~ unary_op_suffix) | (unary_op_prefix ~ expr ~ unary_op_suffix?) }

binary_expr_inner = _{ ("(" ~ expr ~ ")") | literal | ident }

bianry_op_assign = { "=" }
binary_op_plus_eq = { "+=" }
binary_op_minus_eq = { "-=" }
binary_op_mult_eq = { "*=" }
binary_op_div_eq = { "/=" }
binary_op_mod_eq = { "%=" }
binary_op_bitwise_and_eq = { "&=" }
binary_op_bitwise_or_eq = { "|=" }
binary_op_bitwise_xor_eq = { "^=" }
binary_op_bitwise_lshift_eq = { "<<=" }
binary_op_bitwise_rshift_eq = { ">>=" }
binary_op_bitwise_not_eq = { "~=" }
binary_op_logical_and_eq = { "&&=" }
binary_op_logical_or_eq = { "||=" }
binary_op_logical_xor_eq = { "^^=" }
binary_op_logical_not_eq = { "!=" }
binary_op_plus = { "+" }
binary_op_minus = { "-" }
binary_op_mul = { "*" }
binary_op_div = { "/" }
binary_op_mod = { "%" }
binary_op_eq = { "==" }
binary_op_ne = { "!=" }
binary_op_lt = { "<" }
binary_op_gt = { ">" }
binary_op_le = { "<=" }
binary_op_ge = { ">=" }
binary_op_and = { "&" }
binary_op_xor = { "^" }
binary_op_or = { "|" }
binary_op_lshift = { "<<" }
binary_op_rshift = { ">>" }
binary_op_log_and = { "&&" }
binary_op_log_or = { "||" }

binary_op = _{
	binary_op_assign
	| binary_op_plus_eq
	| binary_op_minus_eq
	| binary_op_mult_eq
	| binary_op_div_eq
	| binary_op_mod_eq
	| binary_op_bitwise_and_eq
	| binary_op_bitwise_or_eq
	| binary_op_bitwise_xor_eq
	| binary_op_bitwise_lshift_eq
	| binary_op_bitwise_rshift_eq
	| binary_op_bitwise_not_eq
	| binary_op_logical_and_eq
	| binary_op_logical_or_eq
	| binary_op_logical_xor_eq
	| binary_op_logical_not_eq
    | binary_op_plus
	| binary_op_minus
	| binary_op_mul
	| binary_op_div
	| binary_op_mod
	| binary_op_eq
	| binary_op_ne
	| binary_op_lt
	| binary_op_gt
	| binary_op_le
	| binary_op_ge
	| binary_op_and
	| binary_op_xor
	| binary_op_or
	| binary_op_lshift
	| binary_op_rshift
	| binary_op_log_and
	| binary_op_log_or
}

binary_expr = { binary_expr_inner ~ (bin_op ~ binary_expr_inner)+ }

func_decl_generics = !{ "<" ~ (ident ~ ("extends" ~ type_ident)? ~ ",")* ~ ident ~ ("extends" ~ type_ident)? ~ ">" }
func_decl_params = !{ (ident ~ ":" ~ type_ident ~ ",")* ~ ident ~ ":" ~ type_ident }
func_decl = !{ ident ~ func_decl_generics? ~ func_decl_params? ~ "->" ~ (block | expr) }

extern_func_decl = !{ "extern" ~ ident ~ func_decl_params? ~ "->" ~ type_ident }

func_call_params = @{ ((expr ~ ",")* ~ expr) | "()" }
func_call = @{ ident ~ func_call_params }

func_return = !{ "return" ~ expr }
func_defer = !{ "defer" ~ expr }

statement_inner = {
	conditional_stmt
	| loop_stmt
	| while_stmt
	| declaration
	| func_decl
	| extern_func_decl
	| func_defer
	| func_return
	| break_stmt
	| binary_expr
	| unary_expr
	| func_call
}

statement = @{ statement_inner ~ BLANK* ~ ";"? ~ BLANK* ~ NEWLINE* }

styx = @{ SOI ~ statement* ~ EOI }
