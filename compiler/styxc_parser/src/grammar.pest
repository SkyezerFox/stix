// source: structs/object.pest
// use "../literal/literal.pest"
// use "../ident.pest"

object_key = { ident | string }
object_value = { object | string  }
object_key_value = { object_key ~ ":" ~ object_value }
object = { "{" ~ (object_key_value ~ "," )* ~ object_key_value? ~  "}" }
// source: structs/map.pest
// use "../literal/literal.pest"
// use "../ident.pest"

map_key = { ident | string }
map_value = { object | string }
map_key_value = { map_key ~ "=>" ~ map_value }
map = { "map {" ~ (map_key_value ~ ",")* ~ map_key_value? ~ "}" }
// source: structs/function.pest
func_param_name = @{ ident }
func_param_type = @{ ident }
func_param = { func_param_name ~ ":" ~ func_param_type }
func_name = @{ ident }

func_body = { exprs | expression }
func_inner = { "{" ~ func_body ~ "}" }

func = { func_name ~ (func_param ~ ",")* ~ func_param? ~ "->" ~ func_inner }
// source: operation/binary.pest
// binary_op_add = { "+" }
// binary_op_sub = { "-" }
// binary_op_mul = { "*" }
// binary_op_div = { "/" }
// binary_op_mod = { "%" }
// binary_op_and = { "&" }
// binary_op_or = { "|" }
// binary_op_xor = { "^" }
// binary_op_shl = { "<<" }
// binary_op_shr = { ">>" }
// binary_op_eq = { "==" }
// binary_op_neq = { "!=" }
// binary_op_lt = { "<" }
// binary_op_lte = { "<=" }
// binary_op_gt = { ">" }
// binary_op_gte = { ">=" }

// // TODO: BIDMAS
// binary_op = _{ 
//     binary_op_add |
//     binary_op_sub |
//     binary_op_mul |
//     binary_op_div |
//     binary_op_mod |
//     binary_op_and |
//     binary_op_or |
//     binary_op_xor |
//     binary_op_shl |
//     binary_op_shr |
//     binary_op_eq |
//     binary_op_neq |
//     binary_op_lt |
//     binary_op_lte |
//     binary_op_gt |
//     binary_op_gte
// }

// binary_operation = { binary_op_inner ~ binary_op ~ binary_op_inner }
// binary_op_inner = _{ literal | "(" ~ expression ~ ")" }
// source: operation/operation.pest
// use "./binary.pest"
// use "./unary.pest"
// source: operation/unary.pest
// unary operations
unary_op_assign = { "=" }
unary_op_plus_equals = { "+=" }
unary_op_minus_equals = { "-=" }
unary_op_times_equals = { "*=" }
unary_op_div_equals = { "/=" }
unary_op_mod_equals = { "%=" }
unary_op_and_equals = { "&=" }
unary_op_or_equals = { "|=" }
unary_op_xor_equals = { "^=" }
unary_op_shl_equals = { "<<=" }
unary_op_shr_equals = { ">>=" }
unary_op_incr = { "++" }
unary_op_decr = { "--" }
unary_op_not = { "!" }

unary_op = {
    unary_op_assign |
    unary_op_plus_equals |
    unary_op_minus_equals |
    unary_op_times_equals |
    unary_op_div_equals |
    unary_op_mod_equals |
    unary_op_and_equals |
    unary_op_or_equals |
    unary_op_xor_equals |
    unary_op_shl_equals |
    unary_op_shr_equals |
    unary_op_incr |
    unary_op_decr
}

// unary_operation = { (ident ~ unary_op) | (unary_op_not ~ operatable)  }
// source: expression/assign.pest
// Assignment grammar
// Represents different assignment types

assignment = @{ "let" }// source: expression/import.pest
import_builtin = {
    "import" ~ ident
}
import_aliased = {
    "import" ~ ident ~ "as" ~ ident
}

import = { import_aliased | import_builtin }
 // source: main.pest
WHITESPACE = _{ " " }

line_comment = { "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
block_comment = { "/*" ~ ANY* ~ "*/" }

COMMENT = _{ block_comment | line_comment }

// literals
// use "./literal/literal.pest"
// source: literal/float.pest
// use "../core/core.pest"

float_dp = { "." }

float_hex = _{ num_base_hex ~ num_hex? ~ float_dp ~ num_hex }
float_dec = _{ num_base_dec ~ num_dec? ~ float_dp ~ num_dec }
float_oct = _{ num_base_oct ~ num_oct? ~ float_dp ~ num_oct }
float_bin = _{ num_base_bin ~ num_bin? ~ float_dp ~ num_bin }

float_with_base = _{
	float_hex |
    float_dec |
    float_oct |
    float_bin
}

float_exponent_char = _{ "e" }
float_exponent = { float_exponent_char ~ num_negated? ~ num_dec }
float_default = _{ 
    num_dec? ~ float_dp ~ num_dec ~ float_exponent? |
	num_dec ~ float_exponent
}

float = ${ num_negated? ~ (float_with_base | float_default) }
// source: literal/char.pest
raw_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
char_inner = @{ raw_char }
char = ${ "'" ~ char_inner ~ "'" }
// source: literal/int.pest
// use "../core/core.pest"

int_hex = _{ num_base_hex ~ num_hex }
int_dec = _{ num_base_dec ~ num_dec }
int_oct = _{ num_base_oct ~ num_oct }
int_bin = _{ num_base_bin ~ num_bin }

int_with_base = _{ 
	int_hex |
    int_dec |
    int_oct |
    int_bin
}
int_default = _{ num_dec }
int = ${ num_negated? ~ (int_with_base | int_default) }
// source: literal/literal.pest
// use "./char.pest"
// use "./float.pest"
// use "./int.pest"
// use "./string.pest"

literal = {
    float |
    int |
    string |
    char
}
// source: literal/string.pest
// use "./char.pest"

// string
string_inner = @{ raw_char* }
string = ${ "\"" ~ string_inner ~ "\"" }
// source: literal/num.pest
// negation prefix
num_negated = { "-" }

// num base digits
num_hex = { ASCII_HEX_DIGIT+ }
num_dec = { ASCII_DIGIT+ }
num_oct = { '0'..'7'+ }
num_bin = { '0'..'1'+ }

// base prefixes
num_base_hex = _{ "0x" }
num_base_dec = _{ "0d" }
num_base_oct = _{ "0o" }
num_base_bin = _{ "0b" }
// source: ident.pest
ident = { ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
// source: expression.pest
// Root expression grammar
expression = { func | literal }
exprs = { (expression* ~ "\n") ~ expression | EOI } 
