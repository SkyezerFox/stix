// whitespace
BLANK = _{ " " | "\t" }
WHITESPACE = _{ BLANK | NEWLINE }
// comments
comment_line = { "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
comment_block = { "/*" ~ ANY* ~ "*/" }
COMMENT = _{ comment_line | comment_block }

ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

//
// Literals
//

literal_int_hex = @{ "0x" ~ (ASCII_HEX_DIGIT | "_")+ }
literal_int_oct = @{ "0o" ~ ('0'..'7' | "_")+ }
literal_int_bin = @{ "0b" ~ ("0" | "1" | "_")+ }
literal_int_dec = @{ "0d"? ~ (ASCII_DIGIT | "_")+ }
literal_int = @{ "-"?  ~ (literal_int_hex | literal_int_oct | literal_int_bin | literal_int_dec) }

literal_float_hex = @{ "0x" ~ ((ASCII_HEX_DIGIT | "_")* ~ "." ~ (ASCII_HEX_DIGIT | "_")+) | ((ASCII_HEX_DIGIT | "_")+ ~ "." ~ (ASCII_HEX_DIGIT | "_")*) }
literal_float_oct = @{ "0o" ~ (('0'..'7' | "_")* ~ "." ~ ('0'..'7' | "_")+) | (('0'..'7' | "_")+ ~ "." ~ ('0'..'7' | "_")*) }
literal_float_bin = @{ "0b" ~ (("0" | "1" | "_")* ~ "." ~ ("0" | "1" | "_")+) | (("0" | "1" | "_")+ ~ "." ~ ("0" | "1" | "_")*) }
literal_float_with_exp = @{ (ASCII_DIGIT | "_")+ ~ "e" ~ "-"? ~ (ASCII_DIGIT | "_")+ }
literal_float = @{ "-"? ~ (literal_float_hex | literal_float_oct | literal_float_bin | literal_float_with_exp) }

literal_raw_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
literal_char_inner = @{ literal_raw_char }
literal_char = ${ "'" ~ literal_char_inner ~ "'" }

literal_string_inner = @{ literal_raw_char* }
literal_string = ${ "\"" ~ literal_string_inner ~ "\"" }

literal_bool = { "true" | "false" }

literal_tuple = { "(" ~ (expr ~ "," )+ ~ expr ~ ")" }
literal_array = { "[" ~ (expr ~ ",")+ ~ expr ~ "]" }

literal = ${ 
	literal_tuple
	| literal_string
	| literal_char
	| literal_bool
	| literal_array
	| literal_float
	| literal_int
}

//
// Type Expressions
//

type_binary_op = { "&" | "|" }
type_binary_expr = { ("(" ~ type_expr ~ ")" | type_literal) ~ (type_binary_op ~ type_expr)+ }

type_tuple = { "(" ~ (type_expr ~ ",")*  ~ type_expr ~ ")"}
type_unary_op = { "[]" }
type_unary_expr = { ("(" ~ ")" | type_literal) ~ type_unary_op }
type_unit = { "()" }

type_literal = { type_tuple | ident | type_unit }

type_expr = ${
    type_literal
	| type_binary_expr
    | type_unary_expr
    | ident
}

///
/// Declarations
/// 

token_mut = { "mut" }
stmt_let_decl = !{ "let" ~ (token_mut? ~ ident ~ ",")* ~ token_mut? ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
stmt_mut_decl = !{ token_mut ~ (ident? ~ ",")* ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
stmt_decl = _{ stmt_let_decl | stmt_mut_decl }

// func_decl_generics = !{ "<" ~ (ident ~ ("extends" ~ ident)? ~ ",")* ~ ident ~ ("extends" ~ type_expr)? ~ ">" }
stmt_func_decl_param = !{ ident ~ ":" ~ type_expr }
stmt_func_decl_params = !{ (stmt_func_decl_param ~ ",")* ~ stmt_func_decl_param }
stmt_func_decl = !{ ident ~ stmt_func_decl_params? ~ "->" ~ expr }

stmt_extern_func_decl = !{ "extern" ~ ident ~ stmt_func_decl_params? ~ "->" ~ type_expr }

stmt_class_body = !{ "{" ~  (stmt_func_decl | stmt_class_static_func_decl)* ~ "}" }
stmt_class_static_func_decl = !{ "static" ~ stmt_func_decl }
stmt_class_decl = !{ "class" ~ ident ~ stmt_class_body }

stmt_interface_body = { "{" ~ "}" }
stmt_interface_decl = !{ "interface" ~ ident ~ stmt_class_body }

stmt_const_decl = !{ "const" ~ ident ~ type_expr? ~ "=" ~ expr }

//
// Generic Expressions
//
expr_block = !{ "{" ~ statement* ~ "}" }

expr_func_call_params = @{ ((expr ~ ",")* ~ expr) | "()" }
expr_func_call = !{ ident ~ expr_func_call_params }

//
// Control Flow
//

expr_if= !{ "if" ~ expr ~ expr_block }
expr_else = !{ "else" ~ expr_block }
expr_else_if = !{ "else" ~ "if" ~ expr ~ expr_block }
expr_conditional = !{ expr_if ~ expr_else_if* ~ expr_else? }

expr_loop = !{ "loop" ~ ident? ~ expr_block }
expr_while = !{ "while" ~ expr ~ expr_block }

stmt_break = !{ "break" ~ ident? }
stmt_return = !{ "return" ~ expr }
stmt_defer = !{ "defer" ~ expr }

expr_match_body = !{ (literal ~ "->" ~ expr)* }
expr_match = !{ "match" ~ expr ~ "{" ~ expr_match_body ~ "}"}

//
// Operations
//

token_unary_op_prefix = {
	"~"
	| "!"
	| "&"
	| "*"
}

token_unary_op_suffix = {
	"++"
	| "--"
}

expr_unary_inner = _{ ("(" ~ expr ~ ")") | literal | ident }
expr_unary = !{ 
	(token_unary_op_prefix? ~ expr_unary_inner ~ token_unary_op_suffix) 
	| (token_unary_op_prefix ~ expr_unary_inner ~ token_unary_op_suffix?) 
}

// define all binary operation rules
// length 3 operators
token_binary_op_logical_and_eq = { "&&=" }
token_binary_op_logical_or_eq = { "||=" }
token_binary_op_lshift_eq = { "<<=" }
token_binary_op_rshift_eq = { ">>=" }
token_binary_op_pow_eq = { "**=" }
// length 2 operators
token_binary_op_and_eq = { "&=" }
token_binary_op_as = { "as" }
token_binary_op_bitwise_and_eq = { "&=" }
token_binary_op_bitwise_not_eq = { "~=" }
token_binary_op_bitwise_or_eq = { "|=" }
token_binary_op_bitwise_xor_eq = { "^=" }
token_binary_op_div_eq = { "/=" }
token_binary_op_eq = { "==" }
token_binary_op_ge = { ">=" }
token_binary_op_le = { "<=" }
token_binary_op_logical_and = { "&&" }
token_binary_op_logical_or = { "||" }
token_binary_op_lshift = { "<<" }
token_binary_op_minus_eq = { "-=" }
token_binary_op_mod_eq = { "%=" }
token_binary_op_mul_eq = { "*=" }
token_binary_op_ne = { "!=" }
token_binary_op_not_eq = { "!=" }
token_binary_op_plus_eq = { "+=" }
token_binary_op_rshift = { ">>" }
token_binary_op_pow = { "**" }
// length 1 operators
token_binary_op_assign = { "=" }
token_binary_op_bitwise_and = { "&" }
token_binary_op_bitwise_or = { "|" }
token_binary_op_bitwise_xor = { "^" }
token_binary_op_div = { "/" }
token_binary_op_gt = { ">" }
token_binary_op_lt = { "<" }
token_binary_op_minus = { "-" }
token_binary_op_mod = { "%" }
token_binary_op_mul = { "*" }
token_binary_op_plus = { "+" }

token_binary_op = {
	token_binary_op_lshift_eq
	| token_binary_op_rshift_eq
	| token_binary_op_logical_and_eq
	| token_binary_op_logical_or_eq
	| token_binary_op_and_eq
	| token_binary_op_bitwise_and_eq
	| token_binary_op_bitwise_not_eq
	| token_binary_op_bitwise_or_eq
	| token_binary_op_bitwise_xor_eq
	| token_binary_op_div_eq
	| token_binary_op_eq
	| token_binary_op_ge
	| token_binary_op_le
	| token_binary_op_logical_and
	| token_binary_op_logical_or
	| token_binary_op_minus_eq
	| token_binary_op_mod_eq
	| token_binary_op_mul_eq
	| token_binary_op_ne
	| token_binary_op_not_eq
	| token_binary_op_bitwise_or_eq
	| token_binary_op_plus_eq
	| token_binary_op_plus
	| token_binary_op_bitwise_and
	| token_binary_op_bitwise_or
	| token_binary_op_bitwise_xor
	| token_binary_op_div
	| token_binary_op_gt
	| token_binary_op_lt
	| token_binary_op_mod
	| token_binary_op_mul
	| token_binary_op_minus
    | token_binary_op_assign
}

expr_binary = !{ ("(" ~ expr ~ ")" | ident) ~ (token_binary_op ~ expr)+ }


// 
// Modules
//

stmt_export_block = !{ "{" ~ (ident ~ ",")* ~ ident? ~ "}" }
stmt_export = !{ "export" ~ ((stmt_class_decl | stmt_interface_decl | stmt_func_decl | stmt_const_decl) | stmt_export_block) }

//
// Root-level grammar
//

expr = ${ 
	expr_conditional 
    | expr_func_call
    | expr_match
    | expr_binary
    | expr_unary
    | literal
    | ident
}

statement_inner = {
	stmt_decl
    | stmt_const_decl
    | stmt_class_decl
    | stmt_export
	| stmt_func_decl
	| stmt_extern_func_decl
	| stmt_defer
	| stmt_return
	| stmt_break
    | expr
}

statement = @{ statement_inner ~ BLANK* ~ ";"? ~ BLANK* ~ NEWLINE* }

styx = ${ SOI ~ statement* ~ EOI }
